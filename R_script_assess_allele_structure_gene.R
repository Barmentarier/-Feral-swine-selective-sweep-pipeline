library(tidyverse)
#library(plyr) install but don't load. Messes with the functionality of tidyverse

###Input for this code are a gene transformat file with all genes in the S. scrofa genome and the regions under selection generated by "R_script_rehh"

##Generate a genelist document
setwd("~/Documents")
gtf2 <- read.table('Sus_scrofa.gtf.gz', header = FALSE, sep = '\t')
gtf<-subset(gtf2,V3=="gene")
gtf<-select(gtf,V1,V4,V5,V7,V9)
colnames(gtf)<-c("CHR","START","END","STRAND","GENE_ID")
write.table(gtf,"Gene_list_Sus_scrofa.txt",col.names = T,row.names=F,quote=F,sep='\t')


##Generate a df with all genes present in regions under selection
gtf<-read.table("Gene_list_Sus_scrofa.txt",header=T,sep = '\t',
                colClasses = c("character","integer","integer","character","character"))
gtf$LOW<-((gtf$START+gtf$END)/2+gtf$START)/2
gtf$HIGH<-((gtf$START+gtf$END)/2+gtf$END)/2

regions<-read.table("Regions_under_selection(min_EHHS03).txt",header=T)
regions$MARKER<-as.character(regions$MARKER)

gtfregions<-data.frame(CHR=0,START=0,END=0,STRAND=0,GENE_ID=0,MARKER=0)
gtfNULL<-data.frame(CHR=0,START=0,END=0,STRAND=0,GENE_ID=0,MARKER=0)

range<-c(1:233)
for(i in range){#this for loop assess the presence of a gene within a region under selection. The gtfcur1/2/3/4 variables refer to different
  #subparts of the region under selection to make sure no gene is missed
  gtfcur1<-subset(gtf,START>=regions[i,2]&START<=regions[i,3]&CHR==regions[i,1])
  gtfcur2<-subset(gtf,LOW>=regions[i,2]&LOW<=regions[i,3]&CHR==regions[i,1])
  gtfcur3<-subset(gtf,HIGH>=regions[i,2]&HIGH<=regions[i,3]&CHR==regions[i,1])
  gtfcur4<-subset(gtf,END>=regions[i,2]&END<=regions[i,3]&CHR==regions[i,1])
  gtfcur<-rbind(gtfcur1,gtfcur2,gtfcur3,gtfcur4)
  gtfcur<-gtfcur[,1:6]
  gtfcur<-rbind(gtfcur,gtfNULL)
  gtfcur$MARKER<-ifelse(nrow(gtfcur)==1, 0, regions[i,4])
  gtfregions<-rbind(gtfregions,gtfcur)
}
gtfregions<-subset(gtfregions,CHR!=0)
gtfregions1<-separate(gtfregions,GENE_ID,into=c("Remove", "GENE_ID"),sep="gene_name ")
gtfregions1<-separate(gtfregions1,GENE_ID,into=c("GENE_ID","Remove"),sep=";")
gtfregions1
gtfregions1$REMOVE1<-NULL
gtfregions1$Remove<-NULL
write.table(gtfregions1,"Gene_list_Sus_scrofa.txt",col.names = T,row.names=F,quote=F,sep='\t') #You can choose to change the name of this file to not overwrite the previous one
#note that the file above has a lot of duplicate genes, you could remove those with the distinct() function of dplyr

###Extract SNPs in or surrounding TYRP1
setwd("~/Documents")
regions<-read.table("Regions_under_selection(min_EHHS03).txt",header=T)
genes<-read.table("Gene_list_Sus_scrofa.txt",header=T,sep="\t")
subset(genes,GENE_ID=="TYRP1") #Assess gene location; START=209725636 & END=209745705
markers<-subset(regions,START<=209725636&END>=209745705 & CHR==1) #extract regions under selection fully encompassing TYRP1 
setwd("/home/barmentarier/Documents/Ancestry_paper_2.0/NEW_TYRP1")
bim<-read.table("GRSM_Ref_Geno.bim") #bim file including SNP data present in the GRSM and reference clusters
bim1<-subset(bim,V4>=208651542 & V4<=212065487 & V1==1) #Select markers close to TYRP1 based on marker positions in df "markers"
bim2<-subset(bim1,V4>=(209725636-200000) & V4<=209725636+200000) #narrow down the selection of SNPs until there are only three left, 
#this means you should adjust the "200000" in this line of code
write.table(bim2$V2,"Extract_3snps",quote=F,row.names = F,col.names = F) #input for the PLINK function --extract

########### 
#Break: extract the SNPs surrounding the TYRP1 in PLINK 
###########

#rationale following code: the PED files contain per indidual the nucleotides on both chromosomes for any marker present in the datafile.
#We want to assess per chromosome the allele (nucleotides of all three SNPs) to assess allele frequencies per population.
#The following code is thus a convoluted way to extract the alleles on both chromosomes of an individual 

TYRP1snps<-read.table("PED_GRSM_Ref_3snps.ped",colClasses = "character") #ped file with only the 3 SNPs surrounding TYRP1
TYRP1snps$V1[TYRP1snps$V1=="Haywood"]<-"GRSM"
TYRP1snps$V1[TYRP1snps$V1=="Swain"]<-"GRSM"
TYRP1snps$V1[TYRP1snps$V1=="Sevier"]<-"GRSM"
TYRP1snps$V1[TYRP1snps$V1=="Blount"]<-"GRSM"
TYRP1snps$V1[TYRP1snps$V1=="Graham"]<-"GRSM"

TYRP1snps$FIDIID<-paste0(TYRP1snps$V1,";",TYRP1snps$V2) #FIDIID is an identifier to assess per individual the chromosomes
TP1A<- data.frame(TYRP1snps$FIDIID,TYRP1snps$V7)
colnames(TP1A)<-c("FIDIID","Allele")
TP1B<- data.frame(TYRP1snps$FIDIID,TYRP1snps$V8)
colnames(TP1B)<-c("FIDIID","Allele")
TP2A<- data.frame(TYRP1snps$FIDIID,TYRP1snps$V9)
colnames(TP2A)<-c("FIDIID","Allele")
TP2B<- data.frame(TYRP1snps$FIDIID,TYRP1snps$V10)
colnames(TP2B)<-c("FIDIID","Allele")
TP3A<- data.frame(TYRP1snps$FIDIID,TYRP1snps$V11)
colnames(TP3A)<-c("FIDIID","Allele")
TP3B<- data.frame(TYRP1snps$FIDIID,TYRP1snps$V12)
colnames(TP3B)<-c("FIDIID","Allele")

TP1<-rbind(TP1A,TP1B)
TP2<-rbind(TP2A,TP2B)
TP3<-rbind(TP3A,TP3B)
TP<-cbind(TP1,TP2,TP3) #TP is a dataset with per chromosome the nucleotides for the three SNPs, while maintaining the IID
TP$Alleles<-paste(TP[,2],TP[,4],TP[,6],sep="") #Condence the three SNPs to one allele per chromosome
TP<-data.frame(TP[,1],TP[,7])
colnames(TP)<-c("FIDIID","Alleles")
TP<-separate(TP,FIDIID,into=c("FID","IID"),sep=";")
TPsub<-subset(TP,FID==15|FID==16|FID==17|FID=="GRSM") #Useful in the case your dataset includes populations you are not interested in for this analysis
TPsub$IID<-NULL #IID needs to be removed for the following code to work


##extract count data alleles
dplyTP1<-data.frame(unique(TPsub$Alleles))
colnames(dplyTP1)<-"Alleles"
dplyTP1$Alleles<-as.character(dplyTP1$Alleles)

TYRP1GRSM<-subset(TPsub,FID=="GRSM")
TYRP1GRSM<-plyr::ddply(TYRP1GRSM,1:ncol(TYRP1GRSM),nrow)
f <- function(vec) {#this functions counts the number of times a particular allele is found in GRSM
  if(length(.TYRP1GRSM <- which(vec == TYRP1GRSM$Alleles))) .TYRP1GRSM else NA
}
dplyTP1$GRSM <- TYRP1GRSM$V1[mapply(f,dplyTP1$Alleles)]

TYRP1k16<-subset(TPsub,FID==16)
TYRP1k16<-plyr::ddply(TYRP1k16,1:ncol(TYRP1k16),nrow)
f <- function(vec) {
  if(length(.TYRP1k16 <- which(vec == TYRP1k16$Alleles))) .TYRP1k16 else NA
}
dplyTP1$k16 <- TYRP1k16$V1[mapply(f,dplyTP1$Alleles)]

TYRP1k17<-subset(TPsub,FID==17)
TYRP1k17<-plyr::ddply(TYRP1k17,1:ncol(TYRP1k17),nrow)
f <- function(vec) {
  if(length(.TYRP1k17 <- which(vec == TYRP1k17$Alleles))) .TYRP1k17 else NA
}
dplyTP1$k17 <- TYRP1k17$V1[mapply(f,dplyTP1$Alleles)]

TYRP1k15<-subset(TPsub,FID==15)
TYRP1k15<-plyr::ddply(TYRP1k15,1:ncol(TYRP1k15),nrow)
f <- function(vec) {
  if(length(.TYRP1k15 <- which(vec == TYRP1k15$Alleles))) .TYRP1k15 else NA
}
dplyTP1$k15 <- TYRP1k15$V1[mapply(f,dplyTP1$Alleles)]

dplyTP1[is.na(dplyTP1)] <- 0 #a dataset with count data for the alleles over all chromosomes of the different populations

#the following code provides relative count data
dplyTP1$GRSM<-dplyTP1$GRSM/(sum(dplyTP1$GRSM))
dplyTP1$k16<-dplyTP1$k16/(sum(dplyTP1$k16))
dplyTP1$k17<-dplyTP1$k17/(sum(dplyTP1$k17))
dplyTP1$k15<-dplyTP1$k15/(sum(dplyTP1$k15))
dplyTP1$GRSM<-formatC(dplyTP1$GRSM, digits = 3, format = "f")
dplyTP1$k16<-formatC(dplyTP1$k16, digits = 3, format = "f")
dplyTP1$k17<-formatC(dplyTP1$k17, digits = 3, format = "f")
dplyTP1$k15<-formatC(dplyTP1$k15, digits = 3, format = "f")

write.table(dplyTP1,"TYRP1_3SNP_freq.txt",quote = F,row.names = F,col.names = T)


