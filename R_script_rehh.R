library(rehh)
library(vcfR)
library(rehh)
library(ggplot2)
library(tidyverse)
#library(segmented) install this packages to generate a segmented regression model, 
#but don't load it. Some tidyverse functionality disappears due to it

###The input for this script are phased haplotypes generated by e.g. shapeit. The script assumes a VCF per chromosome.

##Generate iHS for all markers in dataset including plots

#Note that the 3 following for loops can be condensed into one, in the case that the VCFs are very large. 
#I chose to not do that as I tend to run these for loops separately 
range <- c(1:18) #of chromosomes

for(number in range){ #Generate manhattanplots with x=genetic position and y=iHS
  setwd("/home/barmentarier/Documents/backup_oude_laptop/barmentarier/Documents/Extra_GRSM/Sweep")
  df <- paste0("VCF_GRSM_537_chr",number)
  titl <- paste0("GRSM537__CHR", number)
  vcf <- data2haplohh(hap_file = df ,polarize_vcf = FALSE,min_perc_geno.mrk = 50,
                      vcf_reader = "vcfR",
                      verbose = FALSE)
  vcf_scan <-scan_hh(vcf, polarized = FALSE) 
  vcf_ihs <- ihh2ihs(vcf_scan, freqbin = 1)
  cr <- calc_candidate_regions(vcf_ihs, threshold = 2, ignore_sign = TRUE, window_size = 1)
  print(manhattanplot(vcf_ihs, threshold = c(-2,2), cr = cr, xlim=c(0,280000000),ylim = c(-2.5,2.5), pch = 20, main=titl))
}

range <-c(1:18)
for(number in range){#Generate manhattanplots with x=genetic position and y=logPvalue
  setwd("/home/barmentarier/Documents/Extra_GRSM/Sweep")
  df <- paste0("VCF_GRSM_537_chr",number)
  titl <- paste0("GRSM537__CHR", number)
  vcf <- data2haplohh(hap_file = df ,polarize_vcf = FALSE,min_perc_geno.mrk = 50,
                      vcf_reader = "vcfR",
                      verbose = FALSE)
  vcf_scan <-scan_hh(vcf, polarized = FALSE) 
  vcf_ihs <- ihh2ihs(vcf_scan, freqbin = 1)
  print(ggplot(vcf_ihs$ihs, aes(POSITION, LOGPVALUE)) + geom_point() +labs(title = titl)+xlim(0,280000000))
}

range <-c(1:18)
for(number in range){ #generate .txt files with iHS for all markers
  setwd("/home/barmentarier/Documents/Extra_GRSM/Sweep")
  df <- paste0("VCF_GRSM_537_chr",number)
  titl <- paste0("GRSM537__CHR", number,".txt")
  vcf <- data2haplohh(hap_file = df ,polarize_vcf = FALSE,min_perc_geno.mrk = 50,
                      vcf_reader = "vcfR",
                      verbose = FALSE)
  vcf_scan <-scan_hh(vcf, polarized = FALSE) 
  vcf_ihs <- ihh2ihs(vcf_scan, freqbin = 1)
  vcf_ihs <- vcf_ihs$ihs
  cr <- subset(vcf_ihs, LOGPVALUE>=2)
  setwd("/home/barmentarier/Documents/Extra_GRSM/All_IHS_values")
  write.table(cr,file=titl,quote=F,row.names=F,col.names = T)
}

##determine regions under selection
range <- c(1:18)
ihsAll <- data.frame(CHR=0,POSITION=0,LOGPVALUE=0)
for(number in range){
  setwd("/home/barmentarier/Documents/Extra_GRSM/All_IHS_values")
  df<- paste0("GRSM537__CHR",number,".txt")
  roiGRSM <- read.table(df,header=T)
  pos_GRSM <- roiGRSM %>% dplyr::select(CHR,POSITION,LOGPVALUE)
  ihsAll <- rbind(ihsAll, pos_GRSM)
}
ihsAll <- ihsAll[-1,] #dataset with iHS for all markers in dataset
ihs <- subset(ihsAll, LOGPVALUE>=2) #select markers under selection, LOGPVALUE threshold should be evaluated based on datastructure
write.table(ihs,"Markers_under_selection.txt",quote=F,row.names = F,col.names = T)

ihs$MERGE<-paste0(ihs$CHR,ihs$POSITION)

setwd("~/Documents/Extra_GRSM")
bim<-read.table("GRSM_537.bim")
bim$MERGE<-paste0(bim$V1,bim$V4)
bim<-rename(bim,MARKER=V2)

ihs<-merge(ihs,bim,by="MERGE") #annotate markers
ihs<-dplyr::select(ihs,CHR,POSITION,LOGPVALUE,MARKER)
ihs<-arrange(ihs,CHR,POSITION)
ihs$MARKER<-as.character(ihs$MARKER)

#The forloop hereafter calculates for all iHS markers the site-specific EHH. Using this score,
# we can assess the patterns of haplotype decay. The starting and end points of all 
# regions under selection are calculated as follows:
# the EHHS per marker should provide a graph somewhat similar to a bell curve, which implies that the cumulative sum of the 
# EHHS forms a continuous variable. This cumulative sum is used as the response variable in a linear regression model in which
# the explanatory variable is the genetic position. As the EHHS originally provides a bell curve, it is unlikely that this
# linear model is a good fit. More logically, it will be a segmented regression model with two breakpoints. 
# The two breakpoints are calculated in this model and used as the starting and end points of the regions under selection. 
# For each breakpoint, it is assessed whether the EHHS at that particular genetic site is higher than 0.3. 
# If not, the genetic position where the EHHS goes below 0.3 is used as starting or end point of the region under selection.
# See figure S11 of the accompanied manuscript for a visual representation of haplotype decay.
setwd("~/Documents/Extra_GRSM/Sweep")
regions<-data.frame(CHR=0,START=0,END=0,MARKER=0,POSITION=0)
range<-unique(ihs$CHR)
for(i in range){
  vcfname<-paste0("VCF_GRSM_537_chr",i)
  vcf <- data2haplohh(hap_file = vcfname,polarize_vcf = FALSE,min_perc_geno.mrk = 50,
                      vcf_reader = "vcfR", verbose = FALSE)
  ihscur<-subset(ihs,CHR==i)
  ihscur<-as.character(ihscur$MARKER)
    for(word in ihscur){
    res <- calc_ehhs(vcf,mrk=word,include_nhaplo = T,discard_integration_at_border = F) 
    res1<-res$ehhs
    res1$CUM<-cumsum(res1$EHHS)
    
    lmres1<-lm(CUM~POSITION,data=res1)
    segments <- segmented::segmented(lmres1, 
                          seg.Z = ~ POSITION, 
                          npsi = 2)
    
    reslow<-subset(res1,POSITION<=segments$psi[1,2])
    res03<-subset(res1,EHHS>=0.3)
    segment1<-ifelse(reslow[nrow(reslow),2]<0.3,res03[1,1],segments$psi[1,2])
    
    reshigh<-subset(res1,POSITION>=segments$psi[2,2])
    segment2<-ifelse(reshigh[1,2]<0.3,res03[nrow(res03),1],segments$psi[2,2])
    
    curregion<-data.frame(CHR=i,START=segment1,END=segment2,MARKER=word,POSITION=res1[word, 1])
    curregion$MARKER<-as.character(curregion$MARKER)
    regions<-rbind(regions,curregion)
  }
}
regions<-regions[-1,]

setwd("~/Documents/Ensembl")
write.table(regions,"Regions_under_selection(min_EHHS03).txt",quote = F,row.names = F,col.names = T)

##Remove regions under selection that overlap with other regions. 
#In the "Regions_under_selection(min_EHHS03).txt" .txt file, the regions under selection for all iHS markers have been
#represented. This implies that a lot of regions will overlap. The following code removes regions overlapping more that 40%, 
#with the previous region. 
setwd("~/Documents/Ensembl")
regions<-read.table("Regions_under_selection(min_EHHS03).txt",header=T)
setwd("~/Documents/Extra_GRSM")
bim<-read.table("GRSM_537.bim")
setwd("~/Documents/Extra_GRSM/All_IHS_values")
ihs<-read.table("Markers_under_selection.txt", header = T)

tot<-0
range<-1:232 #range = number of iHS markers - 1, so here that is 233 - 1 = 232

for(i in range){
  a<-(regions[i,3]-regions[i+1,2])/(regions[i,3]-regions[i,2])
  tot<-c(tot,a)#tot = (the end of fragment 1 - the start of fragment 2)/ (the end of fragment 1 - the start of fragment 1)
  #e.g. a measurement for overlap between fragment 1 and 2
}

tot<-data.frame(regions$CHR,tot,regions$MARKER,regions$POSITION)
colnames(tot)<-c("CHR","tot","MARKER","POSITION")
tot$tot<-round(tot$tot,digits=4)
tot$tot[tot$tot<0]<-0 #negative values indicate no overlap
tot$tot[tot$tot>2]<-0 #Values above 2 indicate a new chromosome as more than 200% overlap is impossible
tot$LOGP<-ihs$LOGPVALUE

MarkersOverlapping04<-subset(tot,tot>=0.4) #select all regions overlapping more than 40% with the previous
MarkersNotOverlapping04<-tot[!tot$MARKER %in% MarkersOverlapping04$MARKER,] #remove overlapping regions

write.table(MarkersNotOverlapping04,"79_regions_selection.txt",quote=F,row.names = F,col.names = F)

#for loop
regions1<-regions[regions$MARKER %in% test04$MARKER,]
chr<-unique(regions1$CHR)
regions$NUM<-c(1:233)

for(i in chr){
  regionssub<-subset(regions1, CHR==i)
  regionssub1<-subset(regions, CHR==i)
  regionssub1$NUM<-1:nrow(regionssub1) 
  regionssub$NUM<-c((nrow(regionssub1)+1):(nrow(regionssub1)+(nrow(regionssub))))
  titl<-paste0("CHR",i)
  print(ggplot(data=regionssub) + 
          geom_segment(aes(color="Filtered regions under selection",x=START ,y=NUM,xend=END,yend=NUM))+labs(title=titl)+
          geom_segment(data=regionssub1,aes(color="All regions under selection",x=START ,y=NUM,xend=END,yend=NUM))        )
}
